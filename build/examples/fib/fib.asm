; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc fib

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno
	;----- cgpublic
	              public Cfib
Cfib:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- queue_cmp
	;----- commit_cmp
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L2           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- queue_cmp
	;----- commit_cmp
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack


L2:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L3           ; check for branch
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L1
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L1
	;---- queue lbr L4
	;----- cgjump
	 				  lbr	L4

L3:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgsub
	          call  sub16				 ; subtract TOS from SOS on Expression Stack

	;----- cgcall
	          call  Cfib
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- cgsub
	          call  sub16				 ; subtract TOS from SOS on Expression Stack

	;----- cgcall
	          call  Cfib
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L1
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L1

L4:
	;----- end if
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L7
	;----- cgjump
	 				  lbr	L7

L6:
  db 'First ten Fibonacci numbers:', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L7:
	;----- cgldlab
	 				call epush16
	 				  dw  L6
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L8:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L12
	lbr	L10

L12:
	;---- queue lbr L9
	;----- cgjump
	 				  lbr	L9

L11:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L8
	;----- cgjump
	 				  lbr	L8

L9:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfib
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L14
	;----- cgjump
	 				  lbr	L14

L13:
  db '%d'    ;----- cgdefs
	db	$00    ;----- cgdefb

L14:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L13
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 9
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L16
	lbr	L15

L16:
	;----- begin stmt ------
	;---- queue lbr L18
	;----- cgjump
	 				  lbr	L18

L17:
  db 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L18:
	;----- cgldlab
	 				call epush16
	 				  dw  L17
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;---- queue lbr L19
	;----- cgjump
	 				  lbr	L19

L15:
	;----- begin stmt ------
	;---- queue lbr L21
	;----- cgjump
	 				  lbr	L21

L20:
  db ', '    ;----- cgdefs
	db	$00    ;----- cgdefb

L21:
	;----- cgldlab
	 				call epush16
	 				  dw  L20
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L19:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L11
	;----- cgjump
	 				  lbr	L11

L10:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L5
	;----- end return
	;----- end stmt ------
	;---- lbr L5 falls through

L5:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
