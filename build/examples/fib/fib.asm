; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/os_api.inc
#include include/elfc.inc

	           proc fib

#include include/stdlib.inc

#include include/stdio.inc
	;----- cgpublic
	              public Cfib
Cfib:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				gosub s_epush16
	 				  dw 0
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- queue_cmp
	;----- commit_cmp
	;----- cgeq
	          gosub s_eq16				   ; compare TOS == SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 gosub s_dget16       ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L2           ; check for branch
	 				 gosub s_dpop16       ; remove short circuited value from expression stack
	;----- cglit
	 				gosub s_epush16
	 				  dw 1
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- queue_cmp
	;----- commit_cmp
	;----- cgeq
	          gosub s_eq16				   ; compare TOS == SOS on Expression Stack


L2:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 gosub s_dpop16       ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L3           ; check for branch
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack
	;---- queue lbr L1
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L1
	;---- queue lbr L4
	;----- cgjump
	 				  lbr	L4

L3:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cglit
	 				gosub s_epush16
	 				  dw 1
	;----- cgsub
	          gosub s_sub16				 ; subtract TOS from SOS on Expression Stack

	;----- cgcall
	          call  Cfib
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          gosub s_dpush16   	 ; put result on expression stack
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cglit
	 				gosub s_epush16
	 				  dw 2
	;----- cgsub
	          gosub s_sub16				 ; subtract TOS from SOS on Expression Stack

	;----- cgcall
	          call  Cfib
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          gosub s_dpush16   	 ; put result on expression stack
	;----- cgadd
	          gosub s_add16				 ; add TOS and SOS on Expression Stack

	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack
	;---- queue lbr L1
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L1

L4:
	;----- end if
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          gosub s_stkchk      ; check for expression stack creep
	          lbdf  stk_err			 ; exit immediately when stack creep error occurs
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn    			 	     ; return to caller

;----- string table
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  -4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;----- cgldlab
	 				gosub s_epush16
	 				  dw  L6
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				gosub s_epush16
	 				  dw 0
	;----- cgstorlw
	          gosub s_lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack

L7:
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				gosub s_epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          gosub s_lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 gosub s_dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L11
	lbr	L9

L11:
	;---- queue lbr L8
	;----- cgjump
	 				  lbr	L8

L10:
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cginclw
	          gosub s_linc16       ; increment local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack
	;---- queue lbr L7
	;----- cgjump
	 				  lbr	L7

L8:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfib
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          gosub s_dpush16   	 ; put result on expression stack
	;----- cgstorlw
	          gosub s_lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlab
	 				gosub s_epush16
	 				  dw  L12
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				gosub s_epush16
	 				  dw 9
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          gosub s_eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 gosub s_dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L14
	lbr	L13

L14:
	;----- begin stmt ------
	;----- cgldlab
	 				gosub s_epush16
	 				  dw  L15
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;---- queue lbr L16
	;----- cgjump
	 				  lbr	L16

L13:
	;----- begin stmt ------
	;----- cgldlab
	 				gosub s_epush16
	 				  dw  L17
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L16:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L10
	;----- cgjump
	 				  lbr	L10

L9:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          gosub s_lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgpopd
	          gosub s_dpop16   		 ; get result from expression stack
	;---- queue lbr L5
	;----- end return
	;----- end stmt ------
	;---- lbr L5 falls through

L5:
	;----- cgstack
	          gosub s_esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          gosub s_stkchk      ; check for expression stack creep
	          lbdf  stk_err			 ; exit immediately when stack creep error occurs
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn    			 	     ; return to caller

;----- string table

L6:
  db 'First ten Fibonacci numbers:', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L12:
  db '%d'    ;----- cgdefs
	db	$00    ;----- cgdefb

L15:
  db 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L17:
  db ', '    ;----- cgdefs
	db	$00    ;----- cgdefb
	;---- cgpostlude
	             endp
