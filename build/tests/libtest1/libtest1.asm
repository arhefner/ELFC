; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc libtest1

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno

.link .library string.lib

            extrn Cmemchr

            extrn Cmemcmp

            extrn Cmemcpy

            extrn Cmemmove

            extrn Cmemset

            extrn Cstrcat

            extrn Cstrchr

            extrn Cstrcmp

            extrn Cstrcpy

            extrn Cstrcspn

            extrn Cstrdup

            extrn Cstrerror

            extrn Cstrlen

            extrn Cstrncat

            extrn Cstrncmp

            extrn Cstrncpy

            extrn Cstrlcpy

            extrn Cstrpbrk

            extrn Cstrrchr

            extrn Cstrspn

            extrn Cstrstr

            extrn Cstrtok
	;----- cgpublic
	              public CErrors
CErrors:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cv1
Cv1:    ds 64    ;----- cggbss
	;----- cgpublic
	              public Csegp
Csegp:    ds 20    ;----- cggbss
	;----- cgpublic
	              public Cnum
Cnum:    ds 64    ;----- cggbss
	;----- cgpublic
	              public Cresult
Cresult:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cfail
Cfail:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L3
	;----- cgjump
	 				  lbr	L3

L2:
  db '%s failed', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L3:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L2
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- cgincgw
	 				 call vinc16       ; increment global variable
	 				  dw CErrors
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorgw
	 				 call vstor16       ; store value from ES in global variable
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cpr
Cpr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L6
	;----- cgjump
	 				  lbr	L6

L5:
  db '%s', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L6:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L5
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L4:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_memfn
Ctest_memfn:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L9
	;----- cgjump
	 				  lbr	L9

L8:
  db 'memcmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L9:
	;----- cgldlab
	 				call epush16
	 				  dw  L8
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L11
	;----- cgjump
	 				  lbr	L11

L10:
  db 'test01'    ;----- cgdefs
	db	$00    ;----- cgdefb

L11:
	;----- cgldlab
	 				call epush16
	 				  dw  L10
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L13
	;----- cgjump
	 				  lbr	L13

L12:
  db 'test03'    ;----- cgdefs
	db	$00    ;----- cgdefb

L13:
	;----- cgldlab
	 				call epush16
	 				  dw  L12
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 5
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L14           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L16
	;----- cgjump
	 				  lbr	L16

L15:
  db 'memcmp-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L16:
	;----- cgldlab
	 				call epush16
	 				  dw  L15
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L14:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 6
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrtrue
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L17           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L19
	;----- cgjump
	 				  lbr	L19

L18:
  db 'memcmp-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L19:
	;----- cgldlab
	 				call epush16
	 				  dw  L18
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L17:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 6
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -2
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L21
	lbr	L20

L21:
	;----- begin stmt ------
	;---- queue lbr L23
	;----- cgjump
	 				  lbr	L23

L22:
  db 'memcmp-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L23:
	;----- cgldlab
	 				call epush16
	 				  dw  L22
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L20:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 6
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L25
	lbr	L24

L25:
	;----- begin stmt ------
	;---- queue lbr L27
	;----- cgjump
	 				  lbr	L27

L26:
  db 'memcmp-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L27:
	;----- cgldlab
	 				call epush16
	 				  dw  L26
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L24:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L29
	;----- cgjump
	 				  lbr	L29

L28:
  db 'memcpy'    ;----- cgdefs
	db	$00    ;----- cgdefb

L29:
	;----- cgldlab
	 				call epush16
	 				  dw  L28
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L31
	;----- cgjump
	 				  lbr	L31

L30:
  db 'abcdefghijklmnopqrstuvwxyz0123456789'    ;----- cgdefs
	db	$00    ;----- cgdefb

L31:
	;----- cgldlab
	 				call epush16
	 				  dw  L30
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L32           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L34
	;----- cgjump
	 				  lbr	L34

L33:
  db 'memcpy-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L34:
	;----- cgldlab
	 				call epush16
	 				  dw  L33
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L32:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 18
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgcall
	          call  Cmemcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 18
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 18
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L35           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L37
	;----- cgjump
	 				  lbr	L37

L36:
  db 'memcpy-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L37:
	;----- cgldlab
	 				call epush16
	 				  dw  L36
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L35:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 18
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 18
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L38           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L40
	;----- cgjump
	 				  lbr	L40

L39:
  db 'memcpy-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L40:
	;----- cgldlab
	 				call epush16
	 				  dw  L39
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L38:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L42
	;----- cgjump
	 				  lbr	L42

L41:
  db 'memmove'    ;----- cgdefs
	db	$00    ;----- cgdefb

L42:
	;----- cgldlab
	 				call epush16
	 				  dw  L41
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 35
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgcall
	          call  Cmemmove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 35
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L43           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 97
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L43:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L44           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L46
	;----- cgjump
	 				  lbr	L46

L45:
  db 'memmove-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L46:
	;----- cgldlab
	 				call epush16
	 				  dw  L45
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L44:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 36
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 35
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemmove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 35
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L47           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 35
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 57
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L47:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L48           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L50
	;----- cgjump
	 				  lbr	L50

L49:
  db 'memmove-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L50:
	;----- cgldlab
	 				call epush16
	 				  dw  L49
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L48:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L52
	;----- cgjump
	 				  lbr	L52

L51:
  db 'memset'    ;----- cgdefs
	db	$00    ;----- cgdefb

L52:
	;----- cgldlab
	 				call epush16
	 				  dw  L51
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L53:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L57
	lbr	L55

L57:
	;---- queue lbr L54
	;----- cgjump
	 				  lbr	L54

L56:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L53
	;----- cgjump
	 				  lbr	L53

L54:
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cglit
	 				call epush16
	 				  dw -1
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstorib
	          call  pstor8       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L56
	;----- cgjump
	 				  lbr	L56

L55:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemset
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- genbrfalse
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L58           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L60
	;----- cgjump
	 				  lbr	L60

L59:
  db 'memset-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L60:
	;----- cgldlab
	 				call epush16
	 				  dw  L59
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L58:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrtrue
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L61           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L63
	;----- cgjump
	 				  lbr	L63

L62:
  db 'memset-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L63:
	;----- cgldlab
	 				call epush16
	 				  dw  L62
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L61:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L64:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L68
	lbr	L66

L68:
	;---- queue lbr L65
	;----- cgjump
	 				  lbr	L65

L67:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L64
	;----- cgjump
	 				  lbr	L64

L65:
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cglit
	 				call epush16
	 				  dw -1
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstorib
	          call  pstor8       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L67
	;----- cgjump
	 				  lbr	L67

L66:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cgcall
	          call  Cmemset
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L70
	lbr	L69

L70:
	;----- begin stmt ------
	;---- queue lbr L72
	;----- cgjump
	 				  lbr	L72

L71:
  db 'memset-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L72:
	;----- cgldlab
	 				call epush16
	 				  dw  L71
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L69:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cv1
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L74
	lbr	L73

L74:
	;----- begin stmt ------
	;---- queue lbr L76
	;----- cgjump
	 				  lbr	L76

L75:
  db 'memset-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L76:
	;----- cgldlab
	 				call epush16
	 				  dw  L75
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L73:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L78
	;----- cgjump
	 				  lbr	L78

L77:
  db 'memchr'    ;----- cgdefs
	db	$00    ;----- cgdefb

L78:
	;----- cgldlab
	 				call epush16
	 				  dw  L77
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L80
	;----- cgjump
	 				  lbr	L80

L79:
  db '...............X1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L80:
	;----- cgldlab
	 				call epush16
	 				  dw  L79
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 16
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- queue_bool
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L81           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L81           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 49
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L81:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L82           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L84
	;----- cgjump
	 				  lbr	L84

L83:
  db 'memchr-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L84:
	;----- cgldlab
	 				call epush16
	 				  dw  L83
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L82:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 15
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cmemchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L86
	lbr	L85

L86:
	;----- begin stmt ------
	;---- queue lbr L88
	;----- cgjump
	 				  lbr	L88

L87:
  db 'memchr-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L88:
	;----- cgldlab
	 				call epush16
	 				  dw  L87
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L85:
	;----- end if
	;----- end stmt ------

L7:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_dmem
Ctest_dmem:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L91
	;----- cgjump
	 				  lbr	L91

L90:
  db 'malloc'    ;----- cgdefs
	db	$00    ;----- cgdefb

L91:
	;----- cgldlab
	 				call epush16
	 				  dw  L90
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L92:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L96
	lbr	L94

L96:
	;---- queue lbr L93
	;----- cgjump
	 				  lbr	L93

L95:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L92
	;----- cgjump
	 				  lbr	L92

L93:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Csegp
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cglit
	 				call epush16
	 				  dw 64
	;----- cgcall
	          call  Cmalloc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstoriw
	          call  pstor16       ; store value from ES in pointer variable
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L98
	lbr	L97

L98:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L94
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L94

L97:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L99:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L103
	lbr	L101

L103:
	;---- queue lbr L100
	;----- cgjump
	 				  lbr	L100

L102:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L99
	;----- cgjump
	 				  lbr	L99

L100:
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Csegp
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstorib
	          call  pstor8       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L102
	;----- cgjump
	 				  lbr	L102

L101:
	;----- end for
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L95
	;----- cgjump
	 				  lbr	L95

L94:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L105
	lbr	L104

L105:
	;----- begin stmt ------
	;---- queue lbr L107
	;----- cgjump
	 				  lbr	L107

L106:
  db 'malloc-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L107:
	;----- cgldlab
	 				call epush16
	 				  dw  L106
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L104:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L108:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L112
	lbr	L110

L112:
	;---- queue lbr L109
	;----- cgjump
	 				  lbr	L109

L111:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L108
	;----- cgjump
	 				  lbr	L108

L109:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L113:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L117
	lbr	L115

L117:
	;---- queue lbr L114
	;----- cgjump
	 				  lbr	L114

L116:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L113
	;----- cgjump
	 				  lbr	L113

L114:
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Csegp
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L119
	lbr	L118

L119:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L115
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L115

L118:
	;----- end if
	;----- end stmt ------
	;---- queue lbr L116
	;----- cgjump
	 				  lbr	L116

L115:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L121
	lbr	L120

L121:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L110
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L110

L120:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L111
	;----- cgjump
	 				  lbr	L111

L110:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L123
	lbr	L122

L123:
	;----- begin stmt ------
	;---- queue lbr L125
	;----- cgjump
	 				  lbr	L125

L124:
  db 'malloc-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L125:
	;----- cgldlab
	 				call epush16
	 				  dw  L124
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L122:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L127
	;----- cgjump
	 				  lbr	L127

L126:
  db 'free'    ;----- cgdefs
	db	$00    ;----- cgdefb

L127:
	;----- cgldlab
	 				call epush16
	 				  dw  L126
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L128:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L132
	lbr	L130

L132:
	;---- queue lbr L129
	;----- cgjump
	 				  lbr	L129

L131:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L128
	;----- cgjump
	 				  lbr	L128

L129:
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Csegp
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgcall
	          call  Cfree
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;---- queue lbr L131
	;----- cgjump
	 				  lbr	L131

L130:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L134
	;----- cgjump
	 				  lbr	L134

L133:
  db 'calloc'    ;----- cgdefs
	db	$00    ;----- cgdefb

L134:
	;----- cgldlab
	 				call epush16
	 				  dw  L133
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgcall
	          call  Ccalloc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L136
	lbr	L135

L136:
	;----- begin stmt ------
	;---- queue lbr L138
	;----- cgjump
	 				  lbr	L138

L137:
  db 'calloc-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L138:
	;----- cgldlab
	 				call epush16
	 				  dw  L137
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L135:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L139:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L143
	lbr	L141

L143:
	;---- queue lbr L140
	;----- cgjump
	 				  lbr	L140

L142:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L139
	;----- cgjump
	 				  lbr	L139

L140:
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- genbrfalse
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L144           ; check for branch
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L141
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L141

L144:
	;----- end if
	;----- end stmt ------
	;---- queue lbr L142
	;----- cgjump
	 				  lbr	L142

L141:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 64
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L146
	lbr	L145

L146:
	;----- begin stmt ------
	;---- queue lbr L148
	;----- cgjump
	 				  lbr	L148

L147:
  db 'calloc-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L148:
	;----- cgldlab
	 				call epush16
	 				  dw  L147
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L145:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfree
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L150
	;----- cgjump
	 				  lbr	L150

L149:
  db 'realloc'    ;----- cgdefs
	db	$00    ;----- cgdefb

L150:
	;----- cgldlab
	 				call epush16
	 				  dw  L149
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- cgcall
	          call  Cmalloc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L152
	lbr	L151

L152:
	;----- begin stmt ------
	;---- queue lbr L154
	;----- cgjump
	 				  lbr	L154

L153:
  db 'malloc-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L154:
	;----- cgldlab
	 				call epush16
	 				  dw  L153
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L151:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L155:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L159
	lbr	L157

L159:
	;---- queue lbr L156
	;----- cgjump
	 				  lbr	L156

L158:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L155
	;----- cgjump
	 				  lbr	L155

L156:
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstorib
	          call  pstor8       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L158
	;----- cgjump
	 				  lbr	L158

L157:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 257
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Crealloc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L161
	lbr	L160

L161:
	;----- begin stmt ------
	;---- queue lbr L163
	;----- cgjump
	 				  lbr	L163

L162:
  db 'realloc-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L163:
	;----- cgldlab
	 				call epush16
	 				  dw  L162
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L160:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L164:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L168
	lbr	L166

L168:
	;---- queue lbr L165
	;----- cgjump
	 				  lbr	L165

L167:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L164
	;----- cgjump
	 				  lbr	L164

L165:
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L170
	lbr	L169

L170:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L166
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L166

L169:
	;----- end if
	;----- end stmt ------
	;---- queue lbr L167
	;----- cgjump
	 				  lbr	L167

L166:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 123
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L172
	lbr	L171

L172:
	;----- begin stmt ------
	;---- queue lbr L174
	;----- cgjump
	 				  lbr	L174

L173:
  db 'realloc-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L174:
	;----- cgldlab
	 				call epush16
	 				  dw  L173
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L171:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 97
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Crealloc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L176
	lbr	L175

L176:
	;----- begin stmt ------
	;---- queue lbr L178
	;----- cgjump
	 				  lbr	L178

L177:
  db 'realloc-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L178:
	;----- cgldlab
	 				call epush16
	 				  dw  L177
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L175:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L179:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 97
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L183
	lbr	L181

L183:
	;---- queue lbr L180
	;----- cgjump
	 				  lbr	L180

L182:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L179
	;----- cgjump
	 				  lbr	L179

L180:
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L185
	lbr	L184

L185:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L181
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L181

L184:
	;----- end if
	;----- end stmt ------
	;---- queue lbr L182
	;----- cgjump
	 				  lbr	L182

L181:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 97
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L187
	lbr	L186

L187:
	;----- begin stmt ------
	;---- queue lbr L189
	;----- cgjump
	 				  lbr	L189

L188:
  db 'realloc-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L189:
	;----- cgldlab
	 				call epush16
	 				  dw  L188
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L186:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfree
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L89:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cqcmp
Cqcmp:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgindw
	 				call deref16
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  2  ;--- offset
	;----- cgindw
	 				call deref16
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L194
	lbr	L191

L194:
	;----- cglit
	 				call epush16
	 				  dw -1
	;---- queue lbr L192
	;----- cgjump
	 				  lbr	L192

L191:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgindw
	 				call deref16
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  2  ;--- offset
	;----- cgindw
	 				call deref16
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrgt
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L195
	lbr	L193

L195:
	;----- cglit
	 				call epush16
	 				  dw 1
	;---- queue lbr L192
	;----- cgjump
	 				  lbr	L192

L193:
	;----- cglit
	 				call epush16
	 				  dw 0

L192:
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L190
	;----- end return
	;----- end stmt ------
	;---- lbr L190 falls through

L190:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_sort
Ctest_sort:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L198
	;----- cgjump
	 				  lbr	L198

L197:
  db 'qsort'    ;----- cgdefs
	db	$00    ;----- cgdefb

L198:
	;----- cgldlab
	 				call epush16
	 				  dw  L197
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L199:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L203
	lbr	L201

L203:
	;---- queue lbr L200
	;----- cgjump
	 				  lbr	L200

L202:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L199
	;----- cgjump
	 				  lbr	L199

L200:
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Cnum
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgsub
	          call  sub16				 ; subtract TOS from SOS on Expression Stack

	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstoriw
	          call  pstor16       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L202
	;----- cgjump
	 				  lbr	L202

L201:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Cqcmp
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- cgldga
	 				call epush16
	 				  dw Cnum
	;----- cgcall
	          call  Cqsort
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L204:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L208
	lbr	L206

L208:
	;---- queue lbr L205
	;----- cgjump
	 				  lbr	L205

L207:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L204
	;----- cgjump
	 				  lbr	L204

L205:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cnum
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L210
	lbr	L209

L210:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L212
	;----- cgjump
	 				  lbr	L212

L211:
  db 'qsort-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L212:
	;----- cgldlab
	 				call epush16
	 				  dw  L211
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L206
	;----- end break
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L206

L209:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Cnum
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgscale
	 				call scltos2
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L207
	;----- cgjump
	 				  lbr	L207

L206:
	;----- end for
	;----- end stmt ------

L196:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
Ctest_array:	db	$02, $00  ;----- cgdefw LSB first, MSB second
	db	$03, $00  ;----- cgdefw LSB first, MSB second
	db	$05, $00  ;----- cgdefw LSB first, MSB second
	db	$07, $00  ;----- cgdefw LSB first, MSB second
	db	$0b, $00  ;----- cgdefw LSB first, MSB second
	db	$0d, $00  ;----- cgdefw LSB first, MSB second
	db	$11, $00  ;----- cgdefw LSB first, MSB second
	db	$13, $00  ;----- cgdefw LSB first, MSB second
	db	$17, $00  ;----- cgdefw LSB first, MSB second
	db	$1b, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Ctest_array
	;----- cgpublic
	              public Ctest_search
Ctest_search:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L215
	;----- cgjump
	 				  lbr	L215

L214:
  db 'bsearch'    ;----- cgdefs
	db	$00    ;----- cgdefb

L215:
	;----- cgldlab
	 				call epush16
	 				  dw  L214
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 13
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cqcmp
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- cgldga
	 				call epush16
	 				  dw Ctest_array
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cbsearch
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L217
	lbr	L216

L217:
	;----- begin stmt ------
	;---- queue lbr L219
	;----- cgjump
	 				  lbr	L219

L218:
  db 'bsearch-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L219:
	;----- cgldlab
	 				call epush16
	 				  dw  L218
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L216:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgindw
	 				call deref16
	;----- cglit
	 				call epush16
	 				  dw 13
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L221
	lbr	L220

L221:
	;----- begin stmt ------
	;---- queue lbr L223
	;----- cgjump
	 				  lbr	L223

L222:
  db 'bsearch-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L223:
	;----- cgldlab
	 				call epush16
	 				  dw  L222
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L220:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 15
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cqcmp
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- cgldga
	 				call epush16
	 				  dw Ctest_array
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cbsearch
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L225
	lbr	L224

L225:
	;----- begin stmt ------
	;---- queue lbr L227
	;----- cgjump
	 				  lbr	L227

L226:
  db 'bsearch-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L227:
	;----- cgldlab
	 				call epush16
	 				  dw  L226
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L224:
	;----- end if
	;----- end stmt ------

L213:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_memfn
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_dmem
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_sort
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_search
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldgw
	 				call vpush16
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L228
	;----- end return
	;----- end stmt ------
	;---- lbr L228 falls through

L228:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
