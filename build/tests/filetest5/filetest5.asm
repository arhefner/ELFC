; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc filetest5

#define STGROM

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno

.link .library string.lib

            extrn Cmemchr

            extrn Cmemcmp

            extrn Cmemcpy

            extrn Cmemmove

            extrn Cmemset

            extrn Cstrcat

            extrn Cstrchr

            extrn Cstrcmp

            extrn Cstrcpy

            extrn Cstrcspn

            extrn Cstrdup

            extrn Cstrerror

            extrn Cstrlen

            extrn Cstrncat

            extrn Cstrncmp

            extrn Cstrncpy

            extrn Cstrlcpy

            extrn Cstrpbrk

            extrn Cstrrchr

            extrn Cstrspn

            extrn Cstrstr

            extrn Cstrtok
	;----- cgpublic
	              public CErrors
CErrors:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cresult
Cresult:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cs1
Cs1:    ds 80    ;----- cggbss
	;----- cgpublic
	              public Cs2
Cs2:    ds 80    ;----- cggbss
Cstr1:  db '0---|----1----|----2----|----3----|----4----|----5', 10    ;----- cgdefs
	db	$00    ;----- cgdefb
	;----- cgpublic
	              public Cstr1
Cstr2:  db 'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC', 10    ;----- cgdefs
	db	$00    ;----- cgdefb
	;----- cgpublic
	              public Cstr2
Cstr3:  db 'DDDDDDDDDDDDDDDDDDDDDDDD'    ;----- cgdefs
	db	$00    ;----- cgdefb
	;----- cgpublic
	              public Cstr3
Cstr4:  db 'EEEEEEEEEEEEEEEEEEEEEEEE'    ;----- cgdefs
	db	$00    ;----- cgdefb
	;----- cgpublic
	              public Cstr4
Cstr5:  db '%%%%%%%%%%%%%%%%%%%%'    ;----- cgdefs
	db	$00    ;----- cgdefb
	;----- cgpublic
	              public Cstr5
	;----- cgpublic
	              public Cfail
Cfail:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L3
	;----- cgjump
	 				  lbr	L3

L2:
  db '%s failed', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L3:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L2
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- cgincgw
	 				 call vinc16       ; increment global variable
	 				  dw CErrors
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorgw
	 				 call vstor16       ; store value from ES in global variable
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cpr
Cpr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L6
	;----- cgjump
	 				  lbr	L6

L5:
  db '%s', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L6:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L5
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L4:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_fscan
Ctest_fscan:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L9
	;----- cgjump
	 				  lbr	L9

L8:
  db 'fscanf'    ;----- cgdefs
	db	$00    ;----- cgdefb

L9:
	;----- cgldlab
	 				call epush16
	 				  dw  L8
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L11
	;----- cgjump
	 				  lbr	L11

L10:
  db 'fscanf.tst'    ;----- cgdefs
	db	$00    ;----- cgdefb

L11:
	;---- queue lbr L13
	;----- cgjump
	 				  lbr	L13

L12:
  db 'w'    ;----- cgdefs
	db	$00    ;----- cgdefb

L13:
	;----- cgldlab
	 				call epush16
	 				  dw  L12
	;----- cgldlab
	 				call epush16
	 				  dw  L10
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -10  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L15
	lbr	L14

L15:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L17
	;----- cgjump
	 				  lbr	L17

L16:
  db 'fopen-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L17:
	;----- cgldlab
	 				call epush16
	 				  dw  L16
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;---- queue lbr L7
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L7

L14:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L19
	;----- cgjump
	 				  lbr	L19

L18:
  db '%d %x %o'    ;----- cgdefs
	db	$00    ;----- cgdefb

L19:
	;----- cglit
	 				call epush16
	 				  dw 93
	;----- cglit
	 				call epush16
	 				  dw 1024
	;----- cglit
	 				call epush16
	 				  dw -35
	;----- cgldlab
	 				call epush16
	 				  dw  L18
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L21
	;----- cgjump
	 				  lbr	L21

L20:
  db '%s'    ;----- cgdefs
	db	$00    ;----- cgdefb

L21:
	;---- queue lbr L23
	;----- cgjump
	 				  lbr	L23

L22:
  db 'a', 9, '100%  pass', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L23:
	;----- cgldlab
	 				call epush16
	 				  dw  L22
	;----- cgldlab
	 				call epush16
	 				  dw  L20
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Crewind
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L25
	;----- cgjump
	 				  lbr	L25

L24:
  db '%d %x %o'    ;----- cgdefs
	db	$00    ;----- cgdefb

L25:
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L24
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfscanf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L27
	;----- cgjump
	 				  lbr	L27

L26:
  db '%c'    ;----- cgdefs
	db	$00    ;----- cgdefb

L27:
	;----- cgldla
	          call  laddr16       ; push address of local variable on ES
	          dw  -8  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L26
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfscanf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L29
	;----- cgjump
	 				  lbr	L29

L28:
  db '%20s %20s'    ;----- cgdefs
	db	$00    ;----- cgdefb

L29:
	;----- cgldga
	 				call epush16
	 				  dw Cs2
	;----- cgldga
	 				call epush16
	 				  dw Cs1
	;----- cgldlab
	 				call epush16
	 				  dw  L28
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfscanf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw -35
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L31
	lbr	L30

L31:
	;----- begin stmt ------
	;---- queue lbr L33
	;----- cgjump
	 				  lbr	L33

L32:
  db 'fcanf-1 (int)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L33:
	;----- cgldlab
	 				call epush16
	 				  dw  L32
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L30:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 1024
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L35
	lbr	L34

L35:
	;----- begin stmt ------
	;---- queue lbr L37
	;----- cgjump
	 				  lbr	L37

L36:
  db 'fcanf-2 (hex)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L37:
	;----- cgldlab
	 				call epush16
	 				  dw  L36
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L34:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 93
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L39
	lbr	L38

L39:
	;----- begin stmt ------
	;---- queue lbr L41
	;----- cgjump
	 				  lbr	L41

L40:
  db 'fcanf-3 (octal)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L41:
	;----- cgldlab
	 				call epush16
	 				  dw  L40
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L38:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 97
	;----- cgldlb
	          call  lpush8        ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L43
	lbr	L42

L43:
	;----- begin stmt ------
	;---- queue lbr L45
	;----- cgjump
	 				  lbr	L45

L44:
  db 'fcanf-4 (char)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L45:
	;----- cgldlab
	 				call epush16
	 				  dw  L44
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L42:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L47
	;----- cgjump
	 				  lbr	L47

L46:
  db '100%'    ;----- cgdefs
	db	$00    ;----- cgdefb

L47:
	;----- cgldlab
	 				call epush16
	 				  dw  L46
	;----- cgldga
	 				call epush16
	 				  dw Cs1
	;----- cgcall
	          call  Cstrcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L48           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L50
	;----- cgjump
	 				  lbr	L50

L49:
  db 'fcanf-5 (%%)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L50:
	;----- cgldlab
	 				call epush16
	 				  dw  L49
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L48:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L52
	;----- cgjump
	 				  lbr	L52

L51:
  db 'pass'    ;----- cgdefs
	db	$00    ;----- cgdefb

L52:
	;----- cgldlab
	 				call epush16
	 				  dw  L51
	;----- cgldga
	 				call epush16
	 				  dw Cs2
	;----- cgcall
	          call  Cstrcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L53           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L55
	;----- cgjump
	 				  lbr	L55

L54:
  db 'fcanf-6 (string)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L55:
	;----- cgldlab
	 				call epush16
	 				  dw  L54
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L53:
	;----- end if
	;----- end stmt ------

L7:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_fscan
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrtrue
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L57           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L59
	;----- cgjump
	 				  lbr	L59

L58:
  db 'okay'    ;----- cgdefs
	db	$00    ;----- cgdefb

L59:
	;----- cgldlab
	 				call epush16
	 				  dw  L58
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L57:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldgw
	 				call vpush16
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L56
	;----- end return
	;----- end stmt ------
	;---- lbr L56 falls through

L56:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
