; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc filetest3

#define STGROM

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno

.link .library string.lib

            extrn Cmemchr

            extrn Cmemcmp

            extrn Cmemcpy

            extrn Cmemmove

            extrn Cmemset

            extrn Cstrcat

            extrn Cstrchr

            extrn Cstrcmp

            extrn Cstrcpy

            extrn Cstrcspn

            extrn Cstrdup

            extrn Cstrerror

            extrn Cstrlen

            extrn Cstrncat

            extrn Cstrncmp

            extrn Cstrncpy

            extrn Cstrlcpy

            extrn Cstrpbrk

            extrn Cstrrchr

            extrn Cstrspn

            extrn Cstrstr

            extrn Cstrtok
	;----- cgpublic
	              public CErrors
CErrors:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cresult
Cresult:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cs1
Cs1:    ds 80    ;----- cggbss
	;----- cgpublic
	              public Cs2
Cs2:    ds 80    ;----- cggbss
	;----- cgpublic
	              public Cfail
Cfail:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L3
	;----- cgjump
	 				  lbr	L3

L2:
  db '%s failed', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L3:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L2
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- cgincgw
	 				 call vinc16       ; increment global variable
	 				  dw CErrors
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorgw
	 				 call vstor16       ; store value from ES in global variable
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cpr
Cpr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L6
	;----- cgjump
	 				  lbr	L6

L5:
  db '%s', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L6:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L5
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L4:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
L7:    ds 256    ;----- cglbss
	;----- cgpublic
	              public Ctest_sio3
Ctest_sio3:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L10
	;----- cgjump
	 				  lbr	L10

L9:
  db 'ftest5.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L10:
	;---- queue lbr L12
	;----- cgjump
	 				  lbr	L12

L11:
  db 'w+'    ;----- cgdefs
	db	$00    ;----- cgdefb

L12:
	;----- cgldlab
	 				call epush16
	 				  dw  L11
	;----- cgldlab
	 				call epush16
	 				  dw  L9
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L14
	lbr	L13

L14:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L16
	;----- cgjump
	 				  lbr	L16

L15:
  db 'fopen-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L16:
	;----- cgldlab
	 				call epush16
	 				  dw  L15
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;---- queue lbr L8
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L8

L13:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L18
	;----- cgjump
	 				  lbr	L18

L17:
  db 'fwrite'    ;----- cgdefs
	db	$00    ;----- cgdefb

L18:
	;----- cgldlab
	 				call epush16
	 				  dw  L17
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L19:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 131
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrle
	;----- cgle
	          call  lte16				 ; compare TOS <= SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L23
	lbr	L21

L23:
	;---- queue lbr L20
	;----- cgjump
	 				  lbr	L20

L22:
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L19
	;----- cgjump
	 				  lbr	L19

L20:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cmemset
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cfwrite
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L25
	lbr	L24

L25:
	;----- begin stmt ------
	;---- queue lbr L27
	;----- cgjump
	 				  lbr	L27

L26:
  db 'fwrite-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L27:
	;----- cgldlab
	 				call epush16
	 				  dw  L26
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L24:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L22
	;----- cgjump
	 				  lbr	L22

L21:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Crewind
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L29
	;----- cgjump
	 				  lbr	L29

L28:
  db 'fread'    ;----- cgdefs
	db	$00    ;----- cgdefb

L29:
	;----- cgldlab
	 				call epush16
	 				  dw  L28
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L30:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 131
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrle
	;----- cgle
	          call  lte16				 ; compare TOS <= SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L34
	lbr	L32

L34:
	;---- queue lbr L31
	;----- cgjump
	 				  lbr	L31

L33:
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L30
	;----- cgjump
	 				  lbr	L30

L31:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cmemset
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cfread
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L36
	lbr	L35

L36:
	;----- begin stmt ------
	;---- queue lbr L38
	;----- cgjump
	 				  lbr	L38

L37:
  db 'fread-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L38:
	;----- cgldlab
	 				call epush16
	 				  dw  L37
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L35:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L39:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L43
	lbr	L41

L43:
	;---- queue lbr L40
	;----- cgjump
	 				  lbr	L40

L42:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L39
	;----- cgjump
	 				  lbr	L39

L40:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- cgmod
	          call  mod16				 ; SOS modulo TOS on Expression Stack

	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L45
	lbr	L44

L45:
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L41
	;----- end break
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L41

L44:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L42
	;----- cgjump
	 				  lbr	L42

L41:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L47
	lbr	L46

L47:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L49
	;----- cgjump
	 				  lbr	L49

L48:
  db 'fread-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L49:
	;----- cgldlab
	 				call epush16
	 				  dw  L48
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L32
	;----- end break
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L32

L46:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L33
	;----- cgjump
	 				  lbr	L33

L32:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L51
	;----- cgjump
	 				  lbr	L51

L50:
  db 'fclose'    ;----- cgdefs
	db	$00    ;----- cgdefb

L51:
	;----- cgldlab
	 				call epush16
	 				  dw  L50
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L52           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L54
	;----- cgjump
	 				  lbr	L54

L53:
  db 'fclose-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L54:
	;----- cgldlab
	 				call epush16
	 				  dw  L53
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L52:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L56
	;----- cgjump
	 				  lbr	L56

L55:
  db 'fopen'    ;----- cgdefs
	db	$00    ;----- cgdefb

L56:
	;----- cgldlab
	 				call epush16
	 				  dw  L55
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L58
	;----- cgjump
	 				  lbr	L58

L57:
  db 'ftest5.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L58:
	;---- queue lbr L60
	;----- cgjump
	 				  lbr	L60

L59:
  db 'w+'    ;----- cgdefs
	db	$00    ;----- cgdefb

L60:
	;----- cgldlab
	 				call epush16
	 				  dw  L59
	;----- cgldlab
	 				call epush16
	 				  dw  L57
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L62
	lbr	L61

L62:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L64
	;----- cgjump
	 				  lbr	L64

L63:
  db 'fopen-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L64:
	;----- cgldlab
	 				call epush16
	 				  dw  L63
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;---- queue lbr L8
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L8

L61:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L65:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L69
	lbr	L67

L69:
	;---- queue lbr L66
	;----- cgjump
	 				  lbr	L66

L68:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L65
	;----- cgjump
	 				  lbr	L65

L66:
	;----- begin stmt ------
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cglit
	 				call epush16
	 				  dw 53
	;----- cgpopptr
	          call  swap16				 ; swap TOS and SOS on Expression Stack
	          call  dpop16   		 ; get pointer from expression stack
	;----- cgstorib
	          call  pstor8       ; store value from ES in pointer variable
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;---- queue lbr L68
	;----- cgjump
	 				  lbr	L68

L67:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L71
	;----- cgjump
	 				  lbr	L71

L70:
  db 'fwrite'    ;----- cgdefs
	db	$00    ;----- cgdefb

L71:
	;----- cgldlab
	 				call epush16
	 				  dw  L70
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L72:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 16
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L76
	lbr	L74

L76:
	;---- queue lbr L73
	;----- cgjump
	 				  lbr	L73

L75:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L72
	;----- cgjump
	 				  lbr	L72

L73:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cfwrite
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L78
	lbr	L77

L78:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L80
	;----- cgjump
	 				  lbr	L80

L79:
  db 'fwrite-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L80:
	;----- cgldlab
	 				call epush16
	 				  dw  L79
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L74
	;----- end break
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L74

L77:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L75
	;----- cgjump
	 				  lbr	L75

L74:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L82
	;----- cgjump
	 				  lbr	L82

L81:
  db 'rewind'    ;----- cgdefs
	db	$00    ;----- cgdefb

L82:
	;----- cgldlab
	 				call epush16
	 				  dw  L81
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Crewind
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L84
	;----- cgjump
	 				  lbr	L84

L83:
  db 'fread'    ;----- cgdefs
	db	$00    ;----- cgdefb

L84:
	;----- cgldlab
	 				call epush16
	 				  dw  L83
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L85:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 16
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L89
	lbr	L87

L89:
	;---- queue lbr L86
	;----- cgjump
	 				  lbr	L86

L88:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L85
	;----- cgjump
	 				  lbr	L85

L86:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldsa
	 				call epush16
	 				   dw L7
	;----- cgcall
	          call  Cfread
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 256
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L91
	lbr	L90

L91:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L93
	;----- cgjump
	 				  lbr	L93

L92:
  db 'fread-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L93:
	;----- cgldlab
	 				call epush16
	 				  dw  L92
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L87
	;----- end break
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L87

L90:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L88
	;----- cgjump
	 				  lbr	L88

L87:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L95
	;----- cgjump
	 				  lbr	L95

L94:
  db 'fgetc(eof)'    ;----- cgdefs
	db	$00    ;----- cgdefb

L95:
	;----- cgldlab
	 				call epush16
	 				  dw  L94
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfgetc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L97
	lbr	L96

L97:
	;----- begin stmt ------
	;---- queue lbr L99
	;----- cgjump
	 				  lbr	L99

L98:
  db 'feof'    ;----- cgdefs
	db	$00    ;----- cgdefb

L99:
	;----- cgldlab
	 				call epush16
	 				  dw  L98
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L96:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cclearerr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L101
	;----- cgjump
	 				  lbr	L101

L100:
  db 'fclose'    ;----- cgdefs
	db	$00    ;----- cgdefb

L101:
	;----- cgldlab
	 				call epush16
	 				  dw  L100
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L102           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L104
	;----- cgjump
	 				  lbr	L104

L103:
  db 'fclose-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L104:
	;----- cgldlab
	 				call epush16
	 				  dw  L103
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L102:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L106
	;----- cgjump
	 				  lbr	L106

L105:
  db 'fopen'    ;----- cgdefs
	db	$00    ;----- cgdefb

L106:
	;----- cgldlab
	 				call epush16
	 				  dw  L105
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L108
	;----- cgjump
	 				  lbr	L108

L107:
  db 'ftest5.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L108:
	;---- queue lbr L110
	;----- cgjump
	 				  lbr	L110

L109:
  db 'r'    ;----- cgdefs
	db	$00    ;----- cgdefb

L110:
	;----- cgldlab
	 				call epush16
	 				  dw  L109
	;----- cgldlab
	 				call epush16
	 				  dw  L107
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L112
	lbr	L111

L112:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L114
	;----- cgjump
	 				  lbr	L114

L113:
  db 'fopen-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L114:
	;----- cgldlab
	 				call epush16
	 				  dw  L113
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;---- queue lbr L8
	;----- end return
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L8

L111:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L116
	;----- cgjump
	 				  lbr	L116

L115:
  db 'ftell'    ;----- cgdefs
	db	$00    ;----- cgdefb

L116:
	;----- cgldlab
	 				call epush16
	 				  dw  L115
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cftell
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L118
	lbr	L117

L118:
	;----- begin stmt ------
	;---- queue lbr L120
	;----- cgjump
	 				  lbr	L120

L119:
  db 'ftell-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L120:
	;----- cgldlab
	 				call epush16
	 				  dw  L119
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L117:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L122
	;----- cgjump
	 				  lbr	L122

L121:
  db 'fseek'    ;----- cgdefs
	db	$00    ;----- cgdefb

L122:
	;----- cgldlab
	 				call epush16
	 				  dw  L121
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 2
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfseek
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L124
	lbr	L123

L124:
	;----- begin stmt ------
	;---- queue lbr L126
	;----- cgjump
	 				  lbr	L126

L125:
  db 'fseek-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L126:
	;----- cgldlab
	 				call epush16
	 				  dw  L125
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L123:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cftell
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 4096
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L128
	lbr	L127

L128:
	;----- begin stmt ------
	;---- queue lbr L130
	;----- cgjump
	 				  lbr	L130

L129:
  db 'ftell-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L130:
	;----- cgldlab
	 				call epush16
	 				  dw  L129
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L127:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L132
	;----- cgjump
	 				  lbr	L132

L131:
  db 'fseek'    ;----- cgdefs
	db	$00    ;----- cgdefb

L132:
	;----- cgldlab
	 				call epush16
	 				  dw  L131
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cglit
	 				call epush16
	 				  dw 2025
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfseek
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L134
	lbr	L133

L134:
	;----- begin stmt ------
	;---- queue lbr L136
	;----- cgjump
	 				  lbr	L136

L135:
  db 'fseek-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L136:
	;----- cgldlab
	 				call epush16
	 				  dw  L135
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L133:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cftell
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 2025
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L138
	lbr	L137

L138:
	;----- begin stmt ------
	;---- queue lbr L140
	;----- cgjump
	 				  lbr	L140

L139:
  db 'fseek-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L140:
	;----- cgldlab
	 				call epush16
	 				  dw  L139
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L137:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L142
	;----- cgjump
	 				  lbr	L142

L141:
  db 'fseek'    ;----- cgdefs
	db	$00    ;----- cgdefb

L142:
	;----- cgldlab
	 				call epush16
	 				  dw  L141
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cglit
	 				call epush16
	 				  dw 475
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfseek
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L144
	lbr	L143

L144:
	;----- begin stmt ------
	;---- queue lbr L146
	;----- cgjump
	 				  lbr	L146

L145:
  db 'fseek-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L146:
	;----- cgldlab
	 				call epush16
	 				  dw  L145
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L143:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cftell
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 2500
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L148
	lbr	L147

L148:
	;----- begin stmt ------
	;---- queue lbr L150
	;----- cgjump
	 				  lbr	L150

L149:
  db 'fseek-5'    ;----- cgdefs
	db	$00    ;----- cgdefb

L150:
	;----- cgldlab
	 				call epush16
	 				  dw  L149
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L147:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L152
	;----- cgjump
	 				  lbr	L152

L151:
  db 'fclose'    ;----- cgdefs
	db	$00    ;----- cgdefb

L152:
	;----- cgldlab
	 				call epush16
	 				  dw  L151
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L154
	;----- cgjump
	 				  lbr	L154

L153:
  db 'ftest5.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L154:
	;----- cgldlab
	 				call epush16
	 				  dw  L153
	;----- cgcall
	          call  Cunlink
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L8:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_sio3
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldgw
	 				call vpush16
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L155
	;----- end return
	;----- end stmt ------
	;---- lbr L155 falls through

L155:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
