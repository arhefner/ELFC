; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc libtest2

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno

.link .library string.lib

            extrn Cmemchr

            extrn Cmemcmp

            extrn Cmemcpy

            extrn Cmemmove

            extrn Cmemset

            extrn Cstrcat

            extrn Cstrchr

            extrn Cstrcmp

            extrn Cstrcpy

            extrn Cstrcspn

            extrn Cstrdup

            extrn Cstrerror

            extrn Cstrlen

            extrn Cstrncat

            extrn Cstrncmp

            extrn Cstrncpy

            extrn Cstrlcpy

            extrn Cstrpbrk

            extrn Cstrrchr

            extrn Cstrspn

            extrn Cstrstr

            extrn Cstrtok

.link .library ctype.lib

.link .requires Cctype

            extrn  Cisalnum 

            extrn  Cisalpha

            extrn  Ciscntrl

            extrn  Cisdigit

            extrn  Cisgraph

            extrn  Cislower

            extrn  Cisprint

            extrn  Cispunct

            extrn  Cisspace

            extrn  Cisupper

            extrn  Cisxdigit

            extrn  Ctolower

            extrn  Ctoupper
	;----- cgpublic
	              public CErrors
CErrors:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Calpha
Calpha:    ds 64    ;----- cggbss
	;----- cgpublic
	              public Calnum
Calnum:    ds 64    ;----- cggbss
	;----- cgpublic
	              public Cxnum
Cxnum:    ds 64    ;----- cggbss
	;----- cgpublic
	              public Cresult
Cresult:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cfail
Cfail:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L3
	;----- cgjump
	 				  lbr	L3

L2:
  db '%s failed', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L3:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L2
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- cgincgw
	 				 call vinc16       ; increment global variable
	 				  dw CErrors
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorgw
	 				 call vstor16       ; store value from ES in global variable
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cpr
Cpr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L6
	;----- cgjump
	 				  lbr	L6

L5:
  db '%s', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L6:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L5
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L4:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cxstrchr
Cxstrchr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L9
	lbr	L8

L9:
	;----- begin stmt ------
	;----- begin return
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L7
	;----- end return
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L7

L8:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  2  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;---- queue lbr L7
	;----- end return
	;----- end stmt ------
	;---- lbr L7 falls through

L7:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_chrfn
Ctest_chrfn:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -16  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L12
	;----- cgjump
	 				  lbr	L12

L11:
  db 'strchr'    ;----- cgdefs
	db	$00    ;----- cgdefb

L12:
	;----- cgldlab
	 				call epush16
	 				  dw  L11
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L14
	;----- cgjump
	 				  lbr	L14

L13:
  db '...............X1..............X2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L14:
	;----- cgldlab
	 				call epush16
	 				  dw  L13
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_bool
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L15           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L15           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 49
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L15:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L16           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L18
	;----- cgjump
	 				  lbr	L18

L17:
  db 'strchr-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L18:
	;----- cgldlab
	 				call epush16
	 				  dw  L17
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L16:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 90
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L19           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L21
	;----- cgjump
	 				  lbr	L21

L20:
  db 'strchr-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L21:
	;----- cgldlab
	 				call epush16
	 				  dw  L20
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L19:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L23
	;----- cgjump
	 				  lbr	L23

L22:
  db 'strrchr'    ;----- cgdefs
	db	$00    ;----- cgdefb

L23:
	;----- cgldlab
	 				call epush16
	 				  dw  L22
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cstrrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_bool
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L24           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 88
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L24           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cglit
	 				call epush16
	 				  dw 50
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L24:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L25           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L27
	;----- cgjump
	 				  lbr	L27

L26:
  db 'strrchr-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L27:
	;----- cgldlab
	 				call epush16
	 				  dw  L26
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L25:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 90
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cstrrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L28           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L30
	;----- cgjump
	 				  lbr	L30

L29:
  db 'strchr-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L30:
	;----- cgldlab
	 				call epush16
	 				  dw  L29
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L28:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L32
	;----- cgjump
	 				  lbr	L32

L31:
  db 'is*'    ;----- cgdefs
	db	$00    ;----- cgdefb

L32:
	;----- cgldlab
	 				call epush16
	 				  dw  L31
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L34
	;----- cgjump
	 				  lbr	L34

L33:
  db '0123456789'    ;----- cgdefs
	db	$00    ;----- cgdefb

L34:
	;----- cgldlab
	 				call epush16
	 				  dw  L33
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L36
	;----- cgjump
	 				  lbr	L36

L35:
  db 'abcdefghijklmnopqrstuvwxyz'    ;----- cgdefs
	db	$00    ;----- cgdefb

L36:
	;----- cgldlab
	 				call epush16
	 				  dw  L35
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -10  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L38
	;----- cgjump
	 				  lbr	L38

L37:
  db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'    ;----- cgdefs
	db	$00    ;----- cgdefb

L38:
	;----- cgldlab
	 				call epush16
	 				  dw  L37
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -12  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L40
	;----- cgjump
	 				  lbr	L40

L39:
  db 9, 11, 12, 10, 13, ' '    ;----- cgdefs
	db	$00    ;----- cgdefb

L40:
	;----- cgldlab
	 				call epush16
	 				  dw  L39
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -14  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L42
	;----- cgjump
	 				  lbr	L42

L41:
  db '!"#$%&', 39, '()*+,-./:;<=>?@[\]^_`{|}~'    ;----- cgdefs
	db	$00    ;----- cgdefb

L42:
	;----- cgldlab
	 				call epush16
	 				  dw  L41
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -16  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calpha
	;----- cgcall
	          call  Cstrcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -12  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calpha
	;----- cgcall
	          call  Cstrcat
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Calpha
	;----- cgldga
	 				call epush16
	 				  dw Calnum
	;----- cgcall
	          call  Cstrcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calnum
	;----- cgcall
	          call  Cstrcat
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cxnum
	;----- cgcall
	          call  Cstrcpy
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L44
	;----- cgjump
	 				  lbr	L44

L43:
  db 'abcdefABCDEF'    ;----- cgdefs
	db	$00    ;----- cgdefb

L44:
	;----- cgldlab
	 				call epush16
	 				  dw  L43
	;----- cgldga
	 				call epush16
	 				  dw Cxnum
	;----- cgcall
	          call  Cstrcat
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L45:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L49
	lbr	L47

L49:
	;---- queue lbr L46
	;----- cgjump
	 				  lbr	L46

L48:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L45
	;----- cgjump
	 				  lbr	L45

L46:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L51
	;----- cgjump
	 				  lbr	L51

L50:
  db 'isChar Tests: char(%d)', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L51:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L50
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisalnum
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L52           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calnum
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L52:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L53           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L55
	;----- cgjump
	 				  lbr	L55

L54:
  db 'isalnum-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L55:
	;----- cgldlab
	 				call epush16
	 				  dw  L54
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L53:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisalpha
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L56           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calpha
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L56:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L57           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L59
	;----- cgjump
	 				  lbr	L59

L58:
  db 'isalpha-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L59:
	;----- cgldlab
	 				call epush16
	 				  dw  L58
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L57:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ciscntrl
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L60           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L60           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 127
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack


L60:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L61           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L63
	;----- cgjump
	 				  lbr	L63

L62:
  db 'iscrntl-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L63:
	;----- cgldlab
	 				call epush16
	 				  dw  L62
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L61:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisdigit
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L64           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L64:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L65           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L67
	;----- cgjump
	 				  lbr	L67

L66:
  db 'isdigit-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L67:
	;----- cgldlab
	 				call epush16
	 				  dw  L66
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L65:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisgraph
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L68           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 33
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L68           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 126
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack


L68:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L69           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L71
	;----- cgjump
	 				  lbr	L71

L70:
  db 'isgraph-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L71:
	;----- cgldlab
	 				call epush16
	 				  dw  L70
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L69:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cislower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L72           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L72:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L73           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L75
	;----- cgjump
	 				  lbr	L75

L74:
  db 'islower-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L75:
	;----- cgldlab
	 				call epush16
	 				  dw  L74
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L73:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisprint
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L76           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L77           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 126
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack


L77:
	;----- queue_bool
	;----- commit_bool
	;----- commit_bool Q_bool = 2
	;----- cgbool
	 				  call bool16

L76:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L78           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L80
	;----- cgjump
	 				  lbr	L80

L79:
  db 'isprint-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L80:
	;----- cgldlab
	 				call epush16
	 				  dw  L79
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L78:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cispunct
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L81           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -16  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L81:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L82           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L84
	;----- cgjump
	 				  lbr	L84

L83:
  db 'ispunct-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L84:
	;----- cgldlab
	 				call epush16
	 				  dw  L83
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L82:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisspace
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L85           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -14  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L85:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L86           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L88
	;----- cgjump
	 				  lbr	L88

L87:
  db 'isspace-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L88:
	;----- cgldlab
	 				call epush16
	 				  dw  L87
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L86:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L89           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -12  ;--- offset
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L89:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L90           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L92
	;----- cgjump
	 				  lbr	L92

L91:
  db 'isupper-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L92:
	;----- cgldlab
	 				call epush16
	 				  dw  L91
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L90:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisxdigit
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L93           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cxnum
	;----- cgcall
	          call  Cstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L93:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L94           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L96
	;----- cgjump
	 				  lbr	L96

L95:
  db 'isxdigit-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L96:
	;----- cgldlab
	 				call epush16
	 				  dw  L95
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L94:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisalnum
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L97           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calnum
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L97:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L98           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L100
	;----- cgjump
	 				  lbr	L100

L99:
  db 'isalnum-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L100:
	;----- cgldlab
	 				call epush16
	 				  dw  L99
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L98:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisalpha
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L101           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Calpha
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L101:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L102           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L104
	;----- cgjump
	 				  lbr	L104

L103:
  db 'isalpha-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L104:
	;----- cgldlab
	 				call epush16
	 				  dw  L103
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L102:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ciscntrl
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L105           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- gensctrue
	;----- cgbrtrue
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L106           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 126
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack


L106:
	;----- queue_bool
	;----- commit_bool
	;----- commit_bool Q_bool = 2
	;----- cgbool
	 				  call bool16

L105:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L107           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L109
	;----- cgjump
	 				  lbr	L109

L108:
  db 'iscrntl-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L109:
	;----- cgldlab
	 				call epush16
	 				  dw  L108
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L107:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisdigit
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L110           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L110:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L111           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L113
	;----- cgjump
	 				  lbr	L113

L112:
  db 'isdigit-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L113:
	;----- cgldlab
	 				call epush16
	 				  dw  L112
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L111:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisgraph
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L114           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 32
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L114           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 127
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack


L114:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L115           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L117
	;----- cgjump
	 				  lbr	L117

L116:
  db 'isgraph-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L117:
	;----- cgldlab
	 				call epush16
	 				  dw  L116
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L115:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cislower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L118           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L118:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L119           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L121
	;----- cgjump
	 				  lbr	L121

L120:
  db 'islower-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L121:
	;----- cgldlab
	 				call epush16
	 				  dw  L120
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L119:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisprint
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L122           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 31
	;----- queue_cmp
	;----- commit_cmp
	;----- cggt
	          call  gt16				   ; compare TOS > SOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L122           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 127
	;----- queue_cmp
	;----- commit_cmp
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack


L122:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L123           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L125
	;----- cgjump
	 				  lbr	L125

L124:
  db 'isprint-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L125:
	;----- cgldlab
	 				call epush16
	 				  dw  L124
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L123:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cispunct
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L126           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -16  ;--- offset
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L126:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L127           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L129
	;----- cgjump
	 				  lbr	L129

L128:
  db 'ispunct-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L129:
	;----- cgldlab
	 				call epush16
	 				  dw  L128
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L127:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisspace
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L130           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -14  ;--- offset
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L130:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L131           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L133
	;----- cgjump
	 				  lbr	L133

L132:
  db 'isspace-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L133:
	;----- cgldlab
	 				call epush16
	 				  dw  L132
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L131:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L134           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -12  ;--- offset
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L134:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L135           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L137
	;----- cgjump
	 				  lbr	L137

L136:
  db 'isupper-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L137:
	;----- cgldlab
	 				call epush16
	 				  dw  L136
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L135:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisxdigit
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L138           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgldga
	 				call epush16
	 				  dw Cxnum
	;----- cgcall
	          call  Cxstrchr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack

L138:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L139           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L141
	;----- cgjump
	 				  lbr	L141

L140:
  db 'isxdigit-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L141:
	;----- cgldlab
	 				call epush16
	 				  dw  L140
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L139:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L142           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ctolower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgcall
	          call  Cislower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L142:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L143           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L145
	;----- cgjump
	 				  lbr	L145

L144:
  db 'tolower-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L145:
	;----- cgldlab
	 				call epush16
	 				  dw  L144
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L143:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cislower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L146           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ctoupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgcall
	          call  Ctolower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L146:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L147           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L149
	;----- cgjump
	 				  lbr	L149

L148:
  db 'tolower-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L149:
	;----- cgldlab
	 				call epush16
	 				  dw  L148
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L147:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cislower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L150           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ctoupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgcall
	          call  Cisupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack


L150:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L151           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L153
	;----- cgjump
	 				  lbr	L153

L152:
  db 'toupper-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L153:
	;----- cgldlab
	 				call epush16
	 				  dw  L152
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L151:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Cisupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L154           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgcall
	          call  Ctolower
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgcall
	          call  Ctoupper
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- queue_cmp
	;----- commit_cmp
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack


L154:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L155           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L157
	;----- cgjump
	 				  lbr	L157

L156:
  db 'toupper-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L157:
	;----- cgldlab
	 				call epush16
	 				  dw  L156
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L155:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L48
	;----- cgjump
	 				  lbr	L48

L47:
	;----- end for
	;----- end stmt ------

L10:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  16  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_chrfn
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldgw
	 				call vpush16
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L158
	;----- end return
	;----- end stmt ------
	;---- lbr L158 falls through

L158:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
