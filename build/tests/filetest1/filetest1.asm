; -------------------------------------------------------------------
; This file generated by ElfC, based on SubC
; SubC Copyright 2012-2025 by Nils Holm
; -------------------------------------------------------------------
#include include/ops_c.inc
#include include/bios.inc
#include include/kernel.inc
#include include/elfc.inc

	           proc filetest1

            extrn C_init

            extrn C_fdinit

            extrn C_fdtable

            extrn C_fildes

            extrn Cabort

            extrn Cabs

            extrn Catexit      

            extrn Cexit            

            extrn Cmalloc

            extrn Ccalloc 

            extrn Crealloc

            extrn Cfree  

            extrn Catoi 

            extrn Citoa           

            extrn Citox

            extrn Citou           

            extrn Cdiv 

            extrn Cbsearch              

            extrn Cqsort

            extrn Crand

            extrn Csrand

            extrn Ccreat

            extrn Copen

            extrn Cclose

            extrn Cread

            extrn Cwrite

            extrn Clseek

            extrn Cunlink

            extrn Crename

            extrn Cmin

            extrn Cmax

            extrn Cstdin

            extrn Cstdout

            extrn Cstderr

            extrn Cputs

            extrn Cputstr

            extrn Cgets

            extrn Cputch

            extrn Cgetch

            extrn Cputchar

            extrn Cgetchar

            extrn Cfdopen

            extrn Cfclose

            extrn Cfopen

            extrn Cferror

            extrn Cfeof

            extrn Cclearerr

            extrn Cfgetc

            extrn Cfputc

            extrn Cfgets

            extrn Cfputs

            extrn Cungetc

            extrn Cfread

            extrn Cfwrite

            extrn Cfflush

            extrn Cfprintf

            extrn Ckprintf

            extrn Cprintf

            extrn Csprintf

            extrn Cvfprintf

            extrn Cvprintf

            extrn Cvsprintf

            extrn Cfscanf

            extrn Cscanf

            extrn Csscanf

            extrn Cfgetpos

            extrn Cfsetpos

            extrn Cfseek

            extrn Cftell

            extrn Cperror

            extrn Crewind

            extrn Cremove

            extrn Ctmpnam

            extrn Ctmpfile

            extrn Cfileno

.link .library string.lib

            extrn Cmemchr

            extrn Cmemcmp

            extrn Cmemcpy

            extrn Cmemmove

            extrn Cmemset

            extrn Cstrcat

            extrn Cstrchr

            extrn Cstrcmp

            extrn Cstrcpy

            extrn Cstrcspn

            extrn Cstrdup

            extrn Cstrerror

            extrn Cstrlen

            extrn Cstrncat

            extrn Cstrncmp

            extrn Cstrncpy

            extrn Cstrlcpy

            extrn Cstrpbrk

            extrn Cstrrchr

            extrn Cstrspn

            extrn Cstrstr

            extrn Cstrtok
	;----- cgpublic
	              public Cbuf
Cbuf:    ds 128    ;----- cggbss
	;----- cgpublic
	              public Ctn1
Ctn1:    ds 8    ;----- cggbss
	;----- cgpublic
	              public Ctn2
Ctn2:    ds 8    ;----- cggbss
	;----- cgpublic
	              public CErrors
CErrors:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cresult
Cresult:	db	$00, $00  ;----- cgdefw LSB first, MSB second
	;----- cgpublic
	              public Cfail
Cfail:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L3
	;----- cgjump
	 				  lbr	L3

L2:
  db '%s failed', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L3:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L2
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldgw
	 				call vpush16
	 				  dw CErrors
	;----- cgincgw
	 				 call vinc16       ; increment global variable
	 				  dw CErrors
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorgw
	 				 call vstor16       ; store value from ES in global variable
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------

L1:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cpr
Cpr:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;---- queue lbr L6
	;----- cgjump
	 				  lbr	L6

L5:
  db '%s', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L6:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  0  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L5
	;----- cgcall
	          call  Cprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L4:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_file
Ctest_file:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L9
	;----- cgjump
	 				  lbr	L9

L8:
  db 'remove'    ;----- cgdefs
	db	$00    ;----- cgdefb

L9:
	;----- cgldlab
	 				call epush16
	 				  dw  L8
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L11
	;----- cgjump
	 				  lbr	L11

L10:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L11:
	;---- queue lbr L13
	;----- cgjump
	 				  lbr	L13

L12:
  db 'w'    ;----- cgdefs
	db	$00    ;----- cgdefb

L13:
	;----- cgldlab
	 				call epush16
	 				  dw  L12
	;----- cgldlab
	 				call epush16
	 				  dw  L10
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L15
	lbr	L14

L15:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L17
	;----- cgjump
	 				  lbr	L17

L16:
  db 'fopen-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L17:
	;----- cgldlab
	 				call epush16
	 				  dw  L16
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L19
	;----- cgjump
	 				  lbr	L19

L18:
  db 'remove'    ;----- cgdefs
	db	$00    ;----- cgdefb

L19:
	;----- cgldlab
	 				call epush16
	 				  dw  L18
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------

L14:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L21
	;----- cgjump
	 				  lbr	L21

L20:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L21:
	;----- cgldlab
	 				call epush16
	 				  dw  L20
	;----- cgcall
	          call  Cremove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L23
	lbr	L22

L23:
	;----- begin stmt ------
	;---- queue lbr L25
	;----- cgjump
	 				  lbr	L25

L24:
  db 'remove-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L25:
	;----- cgldlab
	 				call epush16
	 				  dw  L24
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L22:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L27
	;----- cgjump
	 				  lbr	L27

L26:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L27:
	;----- cgldlab
	 				call epush16
	 				  dw  L26
	;----- cgcall
	          call  Cremove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrge
	;----- cgge
	          call  gte16				 ; compare TOS >= SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L29
	lbr	L28

L29:
	;----- begin stmt ------
	;---- queue lbr L31
	;----- cgjump
	 				  lbr	L31

L30:
  db 'remove-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L31:
	;----- cgldlab
	 				call epush16
	 				  dw  L30
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L28:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L33
	;----- cgjump
	 				  lbr	L33

L32:
  db 'rename'    ;----- cgdefs
	db	$00    ;----- cgdefb

L33:
	;----- cgldlab
	 				call epush16
	 				  dw  L32
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L35
	;----- cgjump
	 				  lbr	L35

L34:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L35:
	;---- queue lbr L37
	;----- cgjump
	 				  lbr	L37

L36:
  db 'ftest2.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L37:
	;----- cgldlab
	 				call epush16
	 				  dw  L36
	;----- cgldlab
	 				call epush16
	 				  dw  L34
	;----- cgcall
	          call  Crename
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrge
	;----- cgge
	          call  gte16				 ; compare TOS >= SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L39
	lbr	L38

L39:
	;----- begin stmt ------
	;---- queue lbr L41
	;----- cgjump
	 				  lbr	L41

L40:
  db 'rename-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L41:
	;----- cgldlab
	 				call epush16
	 				  dw  L40
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L38:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L43
	;----- cgjump
	 				  lbr	L43

L42:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L43:
	;---- queue lbr L45
	;----- cgjump
	 				  lbr	L45

L44:
  db 'w'    ;----- cgdefs
	db	$00    ;----- cgdefb

L45:
	;----- cgldlab
	 				call epush16
	 				  dw  L44
	;----- cgldlab
	 				call epush16
	 				  dw  L42
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L47
	lbr	L46

L47:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L49
	;----- cgjump
	 				  lbr	L49

L48:
  db 'fopen-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L49:
	;----- cgldlab
	 				call epush16
	 				  dw  L48
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L51
	;----- cgjump
	 				  lbr	L51

L50:
  db 'rename'    ;----- cgdefs
	db	$00    ;----- cgdefb

L51:
	;----- cgldlab
	 				call epush16
	 				  dw  L50
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------

L46:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L53
	;----- cgjump
	 				  lbr	L53

L52:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L53:
	;---- queue lbr L55
	;----- cgjump
	 				  lbr	L55

L54:
  db 'ftest2.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L55:
	;----- cgldlab
	 				call epush16
	 				  dw  L54
	;----- cgldlab
	 				call epush16
	 				  dw  L52
	;----- cgcall
	          call  Crename
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L57
	lbr	L56

L57:
	;----- begin stmt ------
	;---- queue lbr L59
	;----- cgjump
	 				  lbr	L59

L58:
  db 'rename-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L59:
	;----- cgldlab
	 				call epush16
	 				  dw  L58
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L56:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L61
	;----- cgjump
	 				  lbr	L61

L60:
  db 'ftest.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L61:
	;---- queue lbr L63
	;----- cgjump
	 				  lbr	L63

L62:
  db 'ftest2.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L63:
	;----- cgldlab
	 				call epush16
	 				  dw  L62
	;----- cgldlab
	 				call epush16
	 				  dw  L60
	;----- cgcall
	          call  Crename
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrge
	;----- cgge
	          call  gte16				 ; compare TOS >= SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L65
	lbr	L64

L65:
	;----- begin stmt ------
	;---- queue lbr L67
	;----- cgjump
	 				  lbr	L67

L66:
  db 'rename-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L67:
	;----- cgldlab
	 				call epush16
	 				  dw  L66
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L64:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L69
	;----- cgjump
	 				  lbr	L69

L68:
  db 'ftest2.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L69:
	;----- cgldlab
	 				call epush16
	 				  dw  L68
	;----- cgcall
	          call  Cremove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L71
	;----- cgjump
	 				  lbr	L71

L70:
  db 'tmpfile'    ;----- cgdefs
	db	$00    ;----- cgdefb

L71:
	;----- cgldlab
	 				call epush16
	 				  dw  L70
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgcall
	          call  Ctmpfile
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L73
	lbr	L72

L73:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L75
	;----- cgjump
	 				  lbr	L75

L74:
  db 'tmpfile-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L75:
	;----- cgldlab
	 				call epush16
	 				  dw  L74
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L77
	;----- cgjump
	 				  lbr	L77

L76:
  db 'tmpfile'    ;----- cgdefs
	db	$00    ;----- cgdefb

L77:
	;----- cgldlab
	 				call epush16
	 				  dw  L76
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L78
	;----- cgjump
	 				  lbr	L78

L72:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- cglit
	 				call epush16
	 				  dw 165
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgcall
	          call  Cmemset
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgcall
	          call  Cfwrite
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L80
	lbr	L79

L80:
	;----- begin stmt ------
	;---- queue lbr L82
	;----- cgjump
	 				  lbr	L82

L81:
  db 'tmpfile-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L82:
	;----- cgldlab
	 				call epush16
	 				  dw  L81
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L79:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Crewind
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgcall
	          call  Cfread
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  8  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 128
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L84
	lbr	L83

L84:
	;----- begin stmt ------
	;---- queue lbr L86
	;----- cgjump
	 				  lbr	L86

L85:
  db 'tmpfile-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L86:
	;----- cgldlab
	 				call epush16
	 				  dw  L85
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L83:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L88
	;----- cgjump
	 				  lbr	L88

L87:
  db 'temp.%02d'    ;----- cgdefs
	db	$00    ;----- cgdefb

L88:
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindw
	 				call deref16
	;----- cgldlab
	 				call epush16
	 				  dw  L87
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Csprintf
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L90
	lbr	L89

L90:
	;----- begin stmt ------
	;---- queue lbr L92
	;----- cgjump
	 				  lbr	L92

L91:
  db 'tmpfile-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L92:
	;----- cgldlab
	 				call epush16
	 				  dw  L91
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L89:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L94
	;----- cgjump
	 				  lbr	L94

L93:
  db 'r'    ;----- cgdefs
	db	$00    ;----- cgdefb

L94:
	;----- cgldlab
	 				call epush16
	 				  dw  L93
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L96
	lbr	L95

L96:
	;----- begin stmt ------
	;---- queue lbr L98
	;----- cgjump
	 				  lbr	L98

L97:
  db 'tmpfile-5'    ;----- cgdefs
	db	$00    ;----- cgdefb

L98:
	;----- cgldlab
	 				call epush16
	 				  dw  L97
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L95:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------

L78:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L100
	;----- cgjump
	 				  lbr	L100

L99:
  db 'tmpnam'    ;----- cgdefs
	db	$00    ;----- cgdefb

L100:
	;----- cgldlab
	 				call epush16
	 				  dw  L99
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Ctmpnam
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L102
	lbr	L101

L102:
	;----- begin stmt ------
	;---- queue lbr L104
	;----- cgjump
	 				  lbr	L104

L103:
  db 'tmpnam-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L104:
	;----- cgldlab
	 				call epush16
	 				  dw  L103
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L101:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L106
	;----- cgjump
	 				  lbr	L106

L105:
  db 'w'    ;----- cgdefs
	db	$00    ;----- cgdefb

L106:
	;----- cgldlab
	 				call epush16
	 				  dw  L105
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L108
	lbr	L107

L108:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L110
	;----- cgjump
	 				  lbr	L110

L109:
  db 'fopen-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L110:
	;----- cgldlab
	 				call epush16
	 				  dw  L109
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L112
	;----- cgjump
	 				  lbr	L112

L111:
  db 'tmpnam'    ;----- cgdefs
	db	$00    ;----- cgdefb

L112:
	;----- cgldlab
	 				call epush16
	 				  dw  L111
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------

L107:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Ctn2
	;----- cgcall
	          call  Ctmpnam
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L114
	lbr	L113

L114:
	;----- begin stmt ------
	;---- queue lbr L116
	;----- cgjump
	 				  lbr	L116

L115:
  db 'tmpnam-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L116:
	;----- cgldlab
	 				call epush16
	 				  dw  L115
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L113:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Ctn2
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Cstrcmp
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrtrue
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L117           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L119
	;----- cgjump
	 				  lbr	L119

L118:
  db 'tmpnam-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L119:
	;----- cgldlab
	 				call epush16
	 				  dw  L118
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L117:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldga
	 				call epush16
	 				  dw Ctn1
	;----- cgcall
	          call  Cremove
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L7:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Ctest_stdio
Ctest_stdio:	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  -10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- begin stmt ------
	;---- queue lbr L122
	;----- cgjump
	 				  lbr	L122

L121:
  db 'fopen'    ;----- cgdefs
	db	$00    ;----- cgdefb

L122:
	;----- cgldlab
	 				call epush16
	 				  dw  L121
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L124
	;----- cgjump
	 				  lbr	L124

L123:
  db 'ftest3.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L124:
	;---- queue lbr L126
	;----- cgjump
	 				  lbr	L126

L125:
  db 'w+'    ;----- cgdefs
	db	$00    ;----- cgdefb

L126:
	;----- cgldlab
	 				call epush16
	 				  dw  L125
	;----- cgldlab
	 				call epush16
	 				  dw  L123
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L128
	lbr	L127

L128:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L130
	;----- cgjump
	 				  lbr	L130

L129:
  db 'stdio-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L130:
	;----- cgldlab
	 				call epush16
	 				  dw  L129
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L132
	;----- cgjump
	 				  lbr	L132

L131:
  db 'fopen-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L132:
	;----- cgldlab
	 				call epush16
	 				  dw  L131
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L133
	;----- cgjump
	 				  lbr	L133

L127:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L135
	;----- cgjump
	 				  lbr	L135

L134:
  db 'feof'    ;----- cgdefs
	db	$00    ;----- cgdefb

L135:
	;----- cgldlab
	 				call epush16
	 				  dw  L134
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfgetc
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfeof
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrtrue
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbnz	L136           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L138
	;----- cgjump
	 				  lbr	L138

L137:
  db 'feof-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L138:
	;----- cgldlab
	 				call epush16
	 				  dw  L137
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L136:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------

L133:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L140
	;----- cgjump
	 				  lbr	L140

L139:
  db 'ftest3.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L140:
	;---- queue lbr L142
	;----- cgjump
	 				  lbr	L142

L141:
  db 'w'    ;----- cgdefs
	db	$00    ;----- cgdefb

L142:
	;----- cgldlab
	 				call epush16
	 				  dw  L141
	;----- cgldlab
	 				call epush16
	 				  dw  L139
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L144
	lbr	L143

L144:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L146
	;----- cgjump
	 				  lbr	L146

L145:
  db 'stdio-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L146:
	;----- cgldlab
	 				call epush16
	 				  dw  L145
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L148
	;----- cgjump
	 				  lbr	L148

L147:
  db 'fopen-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L148:
	;----- cgldlab
	 				call epush16
	 				  dw  L147
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L149
	;----- cgjump
	 				  lbr	L149

L143:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L151
	;----- cgjump
	 				  lbr	L151

L150:
  db 'fputs'    ;----- cgdefs
	db	$00    ;----- cgdefb

L151:
	;----- cgldlab
	 				call epush16
	 				  dw  L150
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L153
	;----- cgjump
	 				  lbr	L153

L152:
  db '1111111111', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L153:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L152
	;----- cgcall
	          call  Cfputs
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L155
	lbr	L154

L155:
	;----- begin stmt ------
	;---- queue lbr L157
	;----- cgjump
	 				  lbr	L157

L156:
  db 'fputs-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L157:
	;----- cgldlab
	 				call epush16
	 				  dw  L156
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L154:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L159
	;----- cgjump
	 				  lbr	L159

L158:
  db '2222222222', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L159:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L158
	;----- cgcall
	          call  Cfputs
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L161
	lbr	L160

L161:
	;----- begin stmt ------
	;---- queue lbr L163
	;----- cgjump
	 				  lbr	L163

L162:
  db 'fputs-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L163:
	;----- cgldlab
	 				call epush16
	 				  dw  L162
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L160:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L165
	;----- cgjump
	 				  lbr	L165

L164:
  db '3333333333', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L165:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L164
	;----- cgcall
	          call  Cfputs
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L167
	lbr	L166

L167:
	;----- begin stmt ------
	;---- queue lbr L169
	;----- cgjump
	 				  lbr	L169

L168:
  db 'fputs-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L169:
	;----- cgldlab
	 				call epush16
	 				  dw  L168
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L166:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L171
	;----- cgjump
	 				  lbr	L171

L170:
  db '4444444444', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L171:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L170
	;----- cgcall
	          call  Cfputs
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L173
	lbr	L172

L173:
	;----- begin stmt ------
	;---- queue lbr L175
	;----- cgjump
	 				  lbr	L175

L174:
  db 'fputs-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L175:
	;----- cgldlab
	 				call epush16
	 				  dw  L174
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L172:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L177
	;----- cgjump
	 				  lbr	L177

L176:
  db '5555555555', 10    ;----- cgdefs
	db	$00    ;----- cgdefb

L177:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgldlab
	 				call epush16
	 				  dw  L176
	;----- cgcall
	          call  Cfputs
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw -1
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L179
	lbr	L178

L179:
	;----- begin stmt ------
	;---- queue lbr L181
	;----- cgjump
	 				  lbr	L181

L180:
  db 'fputs-5'    ;----- cgdefs
	db	$00    ;----- cgdefb

L181:
	;----- cgldlab
	 				call epush16
	 				  dw  L180
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L178:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfileno
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -10  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L183
	;----- cgjump
	 				  lbr	L183

L182:
  db 'fclose'    ;----- cgdefs
	db	$00    ;----- cgdefb

L183:
	;----- cgldlab
	 				call epush16
	 				  dw  L182
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L184           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L186
	;----- cgjump
	 				  lbr	L186

L185:
  db 'fclose-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L186:
	;----- cgldlab
	 				call epush16
	 				  dw  L185
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L184:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L188
	lbr	L187

L188:
	;----- begin stmt ------
	;---- queue lbr L190
	;----- cgjump
	 				  lbr	L190

L189:
  db 'fclose-2'    ;----- cgdefs
	db	$00    ;----- cgdefb

L190:
	;----- cgldlab
	 				call epush16
	 				  dw  L189
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L187:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;---- queue lbr L192
	;----- cgjump
	 				  lbr	L192

L191:
  db 'ftest3.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L192:
	;---- queue lbr L194
	;----- cgjump
	 				  lbr	L194

L193:
  db 'r'    ;----- cgdefs
	db	$00    ;----- cgdefb

L194:
	;----- cgldlab
	 				call epush16
	 				  dw  L193
	;----- cgldlab
	 				call epush16
	 				  dw  L191
	;----- cgcall
	          call  Cfopen
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  4  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L196
	lbr	L195

L196:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L198
	;----- cgjump
	 				  lbr	L198

L197:
  db 'stdio-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L198:
	;----- cgldlab
	 				call epush16
	 				  dw  L197
	;----- cgcall
	          call  Cperror
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L200
	;----- cgjump
	 				  lbr	L200

L199:
  db 'fopen-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L200:
	;----- cgldlab
	 				call epush16
	 				  dw  L199
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L201
	;----- cgjump
	 				  lbr	L201

L195:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L203
	;----- cgjump
	 				  lbr	L203

L202:
  db 'fgets'    ;----- cgdefs
	db	$00    ;----- cgdefb

L203:
	;----- cgldlab
	 				call epush16
	 				  dw  L202
	;----- cgcall
	          call  Cpr
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 80
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgcall
	          call  Cfgets
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 49
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 1
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin while

L205:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfeof
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- queue_bool
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- commit_bool
	;----- commit_bool Q_bool = 1
	;----- cglognot
	          call  not16				 ; logical not TOS on Expression Stack

	;----- gensctrue
	;----- cgbrfalse
	;----- cgbr
	 				 call  dget16        ; test result on expression stack for short circuit
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L206           ; check for branch
	 				 call  dpop16        ; remove short circuited value from expression stack
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -8  ;--- offset

L206:
	;----- queue_bool
	;----- genbrfalse
	;----- genlogbr
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L204           ; check for branch
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin for
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack

L207:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 10
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrlt
	;----- cglt
	          call  lt16				   ; compare TOS < SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L211
	lbr	L209

L211:
	;---- queue lbr L208
	;----- cgjump
	 				  lbr	L208

L210:
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -6  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L207
	;----- cgjump
	 				  lbr	L207

L208:
	;----- begin stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -6  ;--- offset
	;----- cgadd
	          call  add16				 ; add TOS and SOS on Expression Stack

	;----- cgindb
	 				call deref8
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbrne
	;----- cgne
	          call  ne16				   ; compare TOS != SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L213
	lbr	L212

L213:
	;----- begin stmt ------
	;----- begin stmt ------
	;---- queue lbr L215
	;----- cgjump
	 				  lbr	L215

L214:
  db 'fgets-1'    ;----- cgdefs
	db	$00    ;----- cgdefb

L215:
	;----- cgldlab
	 				call epush16
	 				  dw  L214
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -8  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin break
	;---- queue lbr L209
	;----- end break
	;----- end stmt ------
	;----- end stmt ------
	;----- cgjump
	 				  lbr	L209

L212:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L210
	;----- cgjump
	 				  lbr	L210

L209:
	;----- end for
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -4  ;--- offset
	;----- cginclw
	          call  linc16       ; increment local variable
	          dw  -4  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cglit
	 				call epush16
	 				  dw 80
	;----- cgldga
	 				call epush16
	 				  dw Cbuf
	;----- cgcall
	          call  Cfgets
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  6  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- end stmt ------
	;---- queue lbr L205
	;----- cgjump
	 				  lbr	L205

L204:
	;----- end while
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfileno
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgstorlw
	          call  lstor16      ; store value from ES in local variable
	          dw  -10  ;--- offset
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -2  ;--- offset
	;----- cgcall
	          call  Cfclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- genbrfalse
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cgbrfalse
	;----- cgbr
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	 				 lbz	L216           ; check for branch
	;----- begin stmt ------
	;---- queue lbr L218
	;----- cgjump
	 				  lbr	L218

L217:
  db 'fclose-3'    ;----- cgdefs
	db	$00    ;----- cgdefb

L218:
	;----- cgldlab
	 				call epush16
	 				  dw  L217
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L216:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin if
	;----- cgldlw
	          call  lpush16       ; push value of local variable on ES
	          dw  -10  ;--- offset
	;----- cgcall
	          call  Cclose
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;------ commit push
	;----- cgpushd
	          call  dpush16   		 ; put result on expression stack
	;----- cglit
	 				call epush16
	 				  dw 0
	;----- queue_cmp
	;----- genbrfalse
	;----- genbranch
	;----- cgbreq
	;----- cgeq
	          call  eq16				   ; compare TOS == SOS on Expression Stack

	;----- cgbrcond
	 				 call  dpop16        ; get result from expression stack
	 				 ghi   ra            ; get MSB from result
	 				 str   r2            ; save in M(X)
	 				 glo   ra            ; get LSB from result
	 				 or                  ; D = MSB | LSB
	lbnz	L220
	lbr	L219

L220:
	;----- begin stmt ------
	;---- queue lbr L222
	;----- cgjump
	 				  lbr	L222

L221:
  db 'fclose-4'    ;----- cgdefs
	db	$00    ;----- cgdefb

L222:
	;----- cgldlab
	 				call epush16
	 				  dw  L221
	;----- cgcall
	          call  Cfail
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L219:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------

L201:
	;----- end if
	;----- end stmt ------
	;----- end stmt ------

L149:
	;----- end if
	;----- end stmt ------
	;----- begin stmt ------
	;---- queue lbr L224
	;----- cgjump
	 				  lbr	L224

L223:
  db 'ftest3.tmp'    ;----- cgdefs
	db	$00    ;----- cgdefb

L224:
	;----- cgldlab
	 				call epush16
	 				  dw  L223
	;----- cgcall
	          call  Cunlink
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  2  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------

L120:
	;----- cgstack
	          call  esmove				 ; move pointer for Expression Stack
	          dw  10  ;--- offset
	          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;----- cgpublic
	              public Cmain
Cmain:
  ;----- cgsetup
#ifdef STGROM
      load   r1, $F000  ; set up handler for STG Breakpoint
#endif
	;---- cgentry
	          sex   r2   				 ; make sure X = SP
	          push  rb				 		 ; save current BP (base pointer)
	          copy  r7, rb			 	 ; set BP to current ES location
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_file
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- cgcall
	          call  Ctest_stdio
	;---- queue dpush
	;----- push + pop data not required, data remains unchanged in RA
	;----- end stmt ------
	;----- begin stmt ------
	;----- begin return
	;----- cgldgw
	 				call vpush16
	 				  dw Cresult
	;----- cgpopd
	          call  dpop16   		 ; get result from expression stack
	;---- queue lbr L225
	;----- end return
	;----- end stmt ------
	;---- lbr L225 falls through

L225:
	;----- cgexit
	          sex   r2            ; make sure X = SP
	          call  escheck       ; check for expression stack creep
	          pop   rb				 		 ; restore BP (base pointer)

	          rtn	  			 	     ; return to caller
	;---- cgpostlude
	             endp
